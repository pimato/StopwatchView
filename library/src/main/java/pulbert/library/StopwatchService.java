package pulbert.library;

import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.IBinder;
import android.preference.PreferenceManager;
import android.view.View;
import android.widget.RemoteViews;


/**
 * TODO: Insert description here. (generated by sblitz)
 */
public class StopwatchService extends Service {
    // Member fields
    private int mNumLaps;
    private long mElapsedTime;
    private long mStartTime;
    private boolean mLoadApp;
    private NotificationManager mNotificationManager;

    // Constants for intent information
    // Make this a large number to avoid the alarm ID's which seem to be 1, 2, ...
    // Must also be different than TimerReceiver.IN_USE_NOTIFICATION_ID
    private static final int NOTIFICATION_ID = Integer.MAX_VALUE - 1;

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onCreate() {
        mNumLaps = 0;
        mElapsedTime = 0;
        mStartTime = 0;
        mLoadApp = false;
        mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);

    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (intent == null) {
            return Service.START_NOT_STICKY;
        }

        if (mStartTime == 0 || mElapsedTime == 0 || mNumLaps == 0) {
            // May not have the most recent values.
            readFromSharedPrefs();
        }

        String actionType = intent.getAction();
        long actionTime = intent.getLongExtra(StopwatchView.MESSAGE_TIME, Utils.getTimeNow());
        boolean showNotif = intent.getBooleanExtra(StopwatchView.SHOW_NOTIF, true);
        boolean updateCircle = showNotif; // Don't save updates to the cirle if we're in the app.
        if (actionType.equals(StopwatchView.START_STOPWATCH)) {
            mStartTime = actionTime;
            writeSharedPrefsStarted(mStartTime, updateCircle);
            if (showNotif) {
                setNotification(mStartTime - mElapsedTime, true);
            } else {
                saveNotification(mStartTime - mElapsedTime, true);
            }
        }
        else if (actionType.equals(StopwatchView.STOP_STOPWATCH)) {
            mElapsedTime = mElapsedTime + (actionTime - mStartTime);
            writeSharedPrefsStopped(mElapsedTime, updateCircle);
            if (showNotif) {
                setNotification(actionTime - mElapsedTime, false);
            } else {
                saveNotification(mElapsedTime, false);
            }
        } else if (actionType.equals(StopwatchView.RESET_STOPWATCH)) {
            mLoadApp = false;
            writeSharedPrefsReset(updateCircle);
            clearSavedNotification();
            stopSelf();

        } else if (actionType.equals(StopwatchView.RESET_AND_LAUNCH_STOPWATCH)) {
            mLoadApp = true;
            writeSharedPrefsReset(updateCircle);
            clearSavedNotification();
            closeNotificationShade();
            stopSelf();

        }

        else if (actionType.equals(StopwatchView.SHOW_NOTIF)) {
            // SHOW_NOTIF sent from the DeskClock.onPause
            // If a notification is not displayed, this service's work is over
            if (!showSavedNotification()) {
                stopSelf();
            }
        } else if (actionType.equals(StopwatchView.KILL_NOTIF)) {
            mNotificationManager.cancel(NOTIFICATION_ID);
        }

        // We want this service to continue running until it is explicitly
        // stopped, so return sticky.
        return START_STICKY;
    }

    @Override
    public void onDestroy() {
        mNotificationManager.cancel(NOTIFICATION_ID);
        clearSavedNotification();
        mNumLaps = 0;
        mElapsedTime = 0;
        mStartTime = 0;
        if (mLoadApp) {
            Intent activityIntent = new Intent(getApplicationContext(), getLauncherActivity(getApplicationContext()));
            activityIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startActivity(activityIntent);
            mLoadApp = false;
        }
    }

    private void setNotification(long clockBaseTime, boolean clockRunning) {
        Context context = getApplicationContext();
  //      // Intent to load the app for a non-button click.
        Intent intent = new Intent(context, getLauncherActivity(getApplicationContext()));
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent,
                PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_UPDATE_CURRENT);

        // Set up remoteviews for the notification.
        RemoteViews remoteViewsCollapsed = new RemoteViews(getPackageName(), R.layout.stopwatch_notif_collapsed);

        remoteViewsCollapsed.setOnClickPendingIntent(R.id.swn_collapsed_hitspace, pendingIntent);

        //set Chronometers
        remoteViewsCollapsed.setChronometer(R.id.swn_collapsed_chronometer, clockBaseTime, null, clockRunning);

        remoteViewsCollapsed.setImageViewResource(R.id.notification_icon, R.drawable.stat_notify_stopwatch);
        RemoteViews remoteViewsExpanded = new RemoteViews(getPackageName(), R.layout.stopwatch_notif_expanded);
        remoteViewsExpanded.setOnClickPendingIntent(R.id.swn_expanded_hitspace, pendingIntent);

        remoteViewsExpanded.setChronometer(R.id.swn_expanded_chronometer, clockBaseTime, null, clockRunning);
        remoteViewsExpanded.
                setImageViewResource(R.id.notification_icon, R.drawable.stat_notify_stopwatch);

        if (clockRunning) {

            remoteViewsExpanded.setTextViewText(
                    R.id.swn_left_button, getResources().getText(R.string.sw_pause_button));
            Intent leftButtonIntent = new Intent(context, StopwatchService.class);
            leftButtonIntent.setAction(StopwatchView.STOP_STOPWATCH);
            remoteViewsExpanded.setOnClickPendingIntent(R.id.swn_left_button,
                    PendingIntent.getService(context, 0, leftButtonIntent, 0));
            remoteViewsExpanded.
                    setTextViewCompoundDrawablesRelative(R.id.swn_left_button,
                            R.drawable.ic_pause_black_24dp, 0, 0, 0);

            // Right button: stop clock
            remoteViewsExpanded.setTextViewText(
                    R.id.swn_right_button, getResources().getText(R.string.sw_stop_button));
            Intent rightButtonIntent = new Intent(context, StopwatchService.class);
            rightButtonIntent.setAction(StopwatchView.RESET_AND_LAUNCH_STOPWATCH);
            remoteViewsExpanded.setOnClickPendingIntent(R.id.swn_right_button,
                    PendingIntent.getService(context, 0, rightButtonIntent, 0));
            remoteViewsExpanded.
                    setTextViewCompoundDrawablesRelative(R.id.swn_right_button,
                            R.drawable.ic_notify_stop, 0, 0, 0);
            remoteViewsCollapsed.setViewVisibility(R.id.swn_collapsed_laps, View.GONE);
            remoteViewsExpanded.setViewVisibility(R.id.swn_expanded_laps, View.GONE);

        } else {
            // Left button: start clock
            remoteViewsExpanded.setTextViewText(
                    R.id.swn_left_button, getResources().getText(R.string.sw_resume_button));
            Intent leftButtonIntent = new Intent(context, StopwatchService.class);
            leftButtonIntent.setAction(StopwatchView.START_STOPWATCH);
            remoteViewsExpanded.setOnClickPendingIntent(R.id.swn_left_button, PendingIntent.getService(context, 0, leftButtonIntent, 0));
            remoteViewsExpanded.setTextViewCompoundDrawablesRelative(R.id.swn_left_button, R.drawable.ic_notify_start, 0, 0, 0);


            // Right button: reset Clock
            remoteViewsExpanded.setTextViewText(
                    R.id.swn_right_button, getResources().getText(R.string.sw_stop_button));
            Intent rightButtonIntent = new Intent(context, StopwatchService.class);
            rightButtonIntent.setAction(StopwatchView.RESET_AND_LAUNCH_STOPWATCH);
            remoteViewsExpanded.setOnClickPendingIntent(R.id.swn_right_button,
                    PendingIntent.getService(context, 0, rightButtonIntent, 0));
            remoteViewsExpanded.
                    setTextViewCompoundDrawablesRelative(R.id.swn_right_button,
                            R.drawable.ic_notify_stop, 0, 0, 0);

            // Show stopped string.
            remoteViewsCollapsed.
                    setTextViewText(R.id.swn_collapsed_laps, getString(R.string.swn_paused));
            remoteViewsCollapsed.setViewVisibility(R.id.swn_collapsed_laps, View.VISIBLE);
            remoteViewsExpanded.
                    setTextViewText(R.id.swn_expanded_laps, getString(R.string.swn_paused));
            remoteViewsExpanded.setViewVisibility(R.id.swn_expanded_laps, View.VISIBLE);
        }

        Intent dismissIntent = new Intent(context, StopwatchService.class);
        dismissIntent.setAction(StopwatchView.RESET_STOPWATCH);

        Notification notification = new Notification.Builder(context)
                .setAutoCancel(!clockRunning)
                .setContent(remoteViewsCollapsed)
                .setOngoing(clockRunning)
                .setDeleteIntent(PendingIntent.getService(context, 0, dismissIntent, 0))
                .setSmallIcon(R.drawable.ic_tab_stopwatch_activated)
                .setPriority(Notification.PRIORITY_MAX).build();
        notification.bigContentView = remoteViewsExpanded;
        mNotificationManager.notify(NOTIFICATION_ID, notification);
    }

    /** Save the notification to be shown when the app is closed. **/
    private void saveNotification(long clockTime, boolean clockRunning) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(
                getApplicationContext());
        SharedPreferences.Editor editor = prefs.edit();
        if (clockRunning) {
            editor.putLong(StopwatchView.NOTIF_CLOCK_BASE, clockTime);
            editor.putLong(StopwatchView.NOTIF_CLOCK_ELAPSED, -1);
            editor.putBoolean(StopwatchView.NOTIF_CLOCK_RUNNING, true);
        } else {
            editor.putLong(StopwatchView.NOTIF_CLOCK_ELAPSED, clockTime);
            editor.putLong(StopwatchView.NOTIF_CLOCK_BASE, -1);
            editor.putBoolean(StopwatchView.NOTIF_CLOCK_RUNNING, false);
        }
        editor.putBoolean(StopwatchView.PREF_UPDATE_CIRCLE, false);
        editor.apply();
    }

    /** Show the most recently saved notification. **/
    private boolean showSavedNotification() {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(
                getApplicationContext());
        long clockBaseTime = prefs.getLong(StopwatchView.NOTIF_CLOCK_BASE, -1);
        long clockElapsedTime = prefs.getLong(StopwatchView.NOTIF_CLOCK_ELAPSED, -1);
        boolean clockRunning = prefs.getBoolean(StopwatchView.NOTIF_CLOCK_RUNNING, false);
        int numLaps = prefs.getInt(StopwatchView.PREF_LAP_NUM, -1);
        if (clockBaseTime == -1) {
            if (clockElapsedTime == -1) {
                return false;
            } else {
                // We don't have a clock base time, so the clock is stopped.
                // Use the elapsed time to figure out what time to show.
                mElapsedTime = clockElapsedTime;
                clockBaseTime = Utils.getTimeNow() - clockElapsedTime;
            }
        }
        setNotification(clockBaseTime, clockRunning);
        return true;
    }

    private void clearSavedNotification() {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(
                getApplicationContext());
        SharedPreferences.Editor editor = prefs.edit();
        editor.remove(StopwatchView.NOTIF_CLOCK_BASE);
        editor.remove(StopwatchView.NOTIF_CLOCK_RUNNING);
        editor.remove(StopwatchView.NOTIF_CLOCK_ELAPSED);
        editor.apply();
    }

    private void closeNotificationShade() {
        Intent intent = new Intent();
        intent.setAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
        sendBroadcast(intent);
    }

    private void readFromSharedPrefs() {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(
                getApplicationContext());
        mStartTime = prefs.getLong(StopwatchView.PREF_START_TIME, 0);
        mElapsedTime = prefs.getLong(StopwatchView.PREF_ACCUM_TIME, 0);
        mNumLaps = prefs.getInt(StopwatchView.PREF_LAP_NUM, StopwatchView.STOPWATCH_RESET);
    }

    private long[] readLapsFromPrefs() {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(
                getApplicationContext());
        int numLaps = prefs.getInt(StopwatchView.PREF_LAP_NUM, StopwatchView.STOPWATCH_RESET);
        long[] laps = new long[numLaps];
        long prevLapElapsedTime = 0;
        for (int lap_i = 0; lap_i < numLaps; lap_i++) {
            String key = StopwatchView.PREF_LAP_TIME + Integer.toString(lap_i + 1);
            long lap = prefs.getLong(key, 0);
            if (lap == prevLapElapsedTime && lap_i == numLaps - 1) {
                lap = mElapsedTime;
            }
            laps[numLaps - lap_i - 1] = lap - prevLapElapsedTime;
            prevLapElapsedTime = lap;
        }
        return laps;
    }

    private void writeToSharedPrefs(Long startTime, Long lapTimeElapsed, Long elapsedTime,
                                    Integer state, boolean updateCircle) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(
                getApplicationContext());
        SharedPreferences.Editor editor = prefs.edit();
        if (startTime != null) {
            editor.putLong(StopwatchView.PREF_START_TIME, startTime);
            mStartTime = startTime;
        }
        if (lapTimeElapsed != null) {
            int numLaps = prefs.getInt(StopwatchView.PREF_LAP_NUM, 0);
            if (numLaps == 0) {
                mNumLaps++;
                numLaps++;
            }
            editor.putLong(StopwatchView.PREF_LAP_TIME + Integer.toString(numLaps), lapTimeElapsed);
            numLaps++;
            editor.putLong(StopwatchView.PREF_LAP_TIME + Integer.toString(numLaps), lapTimeElapsed);
            editor.putInt(StopwatchView.PREF_LAP_NUM, numLaps);
        }
        if (elapsedTime != null) {
            editor.putLong(StopwatchView.PREF_ACCUM_TIME, elapsedTime);
            mElapsedTime = elapsedTime;
        }
        if (state != null) {
            if (state == StopwatchView.STOPWATCH_RESET) {
                editor.putInt(StopwatchView.PREF_STATE, StopwatchView.STOPWATCH_RESET);
            } else if (state == StopwatchView.STOPWATCH_RUNNING) {
                editor.putInt(StopwatchView.PREF_STATE, StopwatchView.STOPWATCH_RUNNING);
            } else if (state == StopwatchView.STOPWATCH_STOPPED) {
                editor.putInt(StopwatchView.PREF_STATE, StopwatchView.STOPWATCH_STOPPED);
            }
        }
        editor.putBoolean(StopwatchView.PREF_UPDATE_CIRCLE, updateCircle);
        editor.apply();
    }

    private void writeSharedPrefsStarted(long startTime, boolean updateCircle) {
        writeToSharedPrefs(startTime, null, null, StopwatchView.STOPWATCH_RUNNING, updateCircle);
        if (updateCircle) {
            long time = Utils.getTimeNow();
            SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(
                    getApplicationContext());
            long intervalStartTime = prefs.getLong(
                    StopwatchView.KEY + StopwatchView.PREF_CTV_INTERVAL_START, -1);
            if (intervalStartTime != -1) {
                intervalStartTime = time;
                SharedPreferences.Editor editor = prefs.edit();
                editor.putLong(StopwatchView.KEY + StopwatchView.PREF_CTV_INTERVAL_START,
                        intervalStartTime);
                editor.putBoolean(StopwatchView.KEY + StopwatchView.PREF_CTV_PAUSED, false);
                editor.apply();
            }
        }
    }

    private void writeSharedPrefsLap(long lapTimeElapsed, boolean updateCircle) {
        writeToSharedPrefs(null, lapTimeElapsed, null, null, updateCircle);
        if (updateCircle) {
            long time = Utils.getTimeNow();
            SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(
                    getApplicationContext());
            SharedPreferences.Editor editor = prefs.edit();
            long laps[] = readLapsFromPrefs();
            int numLaps = laps.length;
            long lapTime = laps[1];
            if (numLaps == 2) { // Have only hit lap once.
                editor.putLong(StopwatchView.KEY + StopwatchView.PREF_CTV_INTERVAL, lapTime);
            } else {
                editor.putLong(StopwatchView.KEY + StopwatchView.PREF_CTV_MARKER_TIME, lapTime);
            }
            editor.putLong(StopwatchView.KEY + StopwatchView.PREF_CTV_ACCUM_TIME, 0);
            if (numLaps < StopwatchView.MAX_LAPS) {
                editor.putLong(StopwatchView.KEY + StopwatchView.PREF_CTV_INTERVAL_START, time);
                editor.putBoolean(StopwatchView.KEY + StopwatchView.PREF_CTV_PAUSED, false);
            } else {
                editor.putLong(StopwatchView.KEY + StopwatchView.PREF_CTV_INTERVAL_START, -1);
            }
            editor.apply();
        }
    }

    private void writeSharedPrefsStopped(long elapsedTime, boolean updateCircle) {
        writeToSharedPrefs(null, null, elapsedTime, StopwatchView.STOPWATCH_STOPPED, updateCircle);
        if (updateCircle) {
            long time = Utils.getTimeNow();
            SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(
                    getApplicationContext());
            long accumulatedTime = prefs.getLong(
                    StopwatchView.KEY + StopwatchView.PREF_CTV_ACCUM_TIME, 0);
            long intervalStartTime = prefs.getLong(
                    StopwatchView.KEY + StopwatchView.PREF_CTV_INTERVAL_START, -1);
            accumulatedTime += time - intervalStartTime;
            SharedPreferences.Editor editor = prefs.edit();
            editor.putLong(StopwatchView.KEY + StopwatchView.PREF_CTV_ACCUM_TIME, accumulatedTime);
            editor.putBoolean(StopwatchView.KEY + StopwatchView.PREF_CTV_PAUSED, true);
            editor.putLong(
                    StopwatchView.KEY + StopwatchView.PREF_CTV_CURRENT_INTERVAL, accumulatedTime);
            editor.apply();
        }
    }

    private void writeSharedPrefsReset(boolean updateCircle) {
        writeToSharedPrefs(null, null, null, StopwatchView.STOPWATCH_RESET, updateCircle);
    }

    public static Class<?> getLauncherActivity(Context context)
    {
        String packageName = context.getPackageName();
        Intent launchIntent = context.getPackageManager().getLaunchIntentForPackage(packageName);
        String className = launchIntent.getComponent().getClassName();
        try
        {
            return Class.forName(className);
        }
        catch (ClassNotFoundException e)
        {
            e.printStackTrace();
            return null;
        }
    }
}